<#
.SYNOPSIS
    Automated MCP Git Server Setup Script
    
.DESCRIPTION
    Downloads and configures a portable Python environment with the mcp-server-git package
    and creates a workspace-specific MCP configuration.
    
.PARAMETER InstallDir
    Base directory for MCP installations (default: ~\apps\copilot-mcp)
    
.PARAMETER Force
    Force reinstall even if already exists
    
.EXAMPLE
    .\init-mcp-git.ps1
    
.EXAMPLE
    .\init-mcp-git.ps1 -InstallDir "C:\tools\mcp" -Force
#>

[CmdletBinding()]
param(
    [Parameter()]
    [string]$InstallDir = "$env:USERPROFILE\apps\copilot-mcp",
    
    [Parameter()]
    [string]$GitPath,
    
    [Parameter()]
    [switch]$Force
)

$ErrorActionPreference = "Stop"

# Configuration
$PythonVersion = $null  # Will be resolved dynamically
$GitServerDir = Join-Path $InstallDir "mcp-server-git"
$PythonDir = Join-Path $GitServerDir "python"
$PythonExe = Join-Path $PythonDir "python.exe"
$PipExe = Join-Path $PythonDir "Scripts\pip.exe"
$GitServerExe = Join-Path $PythonDir "Scripts\mcp-server-git.exe"

# Embedded Files - Generated by build-init-script.ps1
# DO NOT EDIT THIS SECTION MANUALLY
$EmbeddedFiles = @(
    @{
        RelativePath = "skills\\ABOUT.md"
        Content = @'
# About This Directory: Agentic Skills

This directory contains `SKILL.md` files that define specialized capabilities for Claude (and other agentic systems) to enhance performance on specific tasks.

## What is a Skill?

A skill is a self-contained folder containing a `SKILL.md` file. This file provides instructions, examples, and guidelines that the AI loads dynamically to ensure consistent, high-quality execution of repeated tasks.

Each skill consists of:
1. **YAML Frontmatter**: Defines metadata like `name` and `description`.
2. **Body**: Contains markdown instructions, examples, and guidelines.

## When to Create a New Skill

Create a new skill when you identify a task or workflow that:
- Is performed repeatedly.
- Requires specific formatting, style, or procedure.
- Benefits from specific examples to ensure correctness.
- Can be encapsulated with clear input/output expectations.

Examples include:
- Generating commit messages in a specific project style.
- Creating pull request descriptions.
- Writing documentation for a specific module.
- Handling specific error types or debugging workflows.

## How to Create a Skill

1. **Create a Folder**: Name the folder descriptively (e.g., `git.commitmsg.imperative`). The folder name acts as the skill ID in some contexts.
2. **Add `SKILL.md`**: Create a file named `SKILL.md` inside the folder.
3. **Define Metadata**:
   Add YAML frontmatter at the top of `SKILL.md`:
   ```yaml
   ---
   name: [Human-readable name]
   description: [Clear description of what the skill does]
   ---
   ```
4. **Write Instructions**:
   - Use clear, actionable language.
   - Provide concrete examples (both good and bad if helpful).
   - List guidelines or constraints.
   - Use sections like `## Instructions`, `## Examples`, `## Guidelines`.

## Directory Structure

```
skills/
  ├── [skill-name]/
  │     ├── SKILL.md
  │     └── [optional-resources]
  └── ...
```

## Best Practices

- **Be Specific**: Target a clear, narrow task.
- **Use Examples**: Examples are often more powerful than abstract instructions.
- **Iterate**: Refine the skill based on how the agent performs.
- **Keep it Self-Contained**: Ideally, a skill should not depend on external context not provided in the `SKILL.md` or the immediate conversation.

'@
    }
    @{
        RelativePath = "skills\\git.attribution\\SKILL.md"
        Content = @'
---
name: Attribution when committing changes to git
description: Guidelines for attributing commits correctly when using git for traceability.
---

# Attribution when committing changes to Git

When using git to commit changes, it is important to attribute the commits correctly for traceability.
When creating a commit, you should set the author information to reflect that the changes were made by GitHub Copilot.

If using commandline/terminal commands, you can set the author information inline with the commit command, for example: `git commit --author="GitHub Copilot <copilot@github.com>" -m "Your commit message"`.

Alternatively, when not using the `commit` command, use git inline config to set the author information, for example: `git -c user.name="GitHub Copilot" -c user.email="copilot@github.com" commit -m "Your commit message"`.

When possible, include your model designation and version in the author name for better traceability, e.g., `--author="GitHub Copilot (gpt-4.0) <copilot@github.com>"`, or `-c user.name="GitHub Copilot (gpt-4.0)"`.

If using MCP tools to commit, then use available parameters to set the author information. If such parameters are not available, do not fall back to commandline tools solely for this purpose, ensure that the commit message clearly indicates that the changes were made by GitHub Copilot for traceability, ; prefer using the co-author field in the commit message body, e.g., `Co-authored-by: GitHub Copilot <copilot@github.com>`.

'@
    }
    @{
        RelativePath = "skills\\git.commitmsg.imperative\\SKILL.md"
        Content = @'
---
name: Writing Imperative Commit Messages
description: Guidelines for crafting effective commit messages in imperative mood.
---

# Writing Imperative Commit Messages

Use simple, imperative subject lines in present tense when crafting commit messages.

## Guidelines
- Start with an action verb: Add, Fix, Refactor, Document, Convert, Update, etc.
- Keep under 50 characters when possible.
- No type prefixes or scope annotations.
- No trailing period.
- The commit message body should be concise and explain the "why" behind changes.

## Examples

### Good Subject Lines
- `Add script to correlate blocking with sp_who2 logs`
- `Fix incorrect field time conversion for controller status event`
- `Document the event service structure`
- `Refactor time conversion for controller events to use UtcToControllerTime method`

### Bad Subject Lines
- `Added script` (Passive)
- `fixing bug` (Gerund/Progressive)
- `feat(core): update logic` (Prefixes not allowed)

'@
    }
    @{
        RelativePath = "skills\\mcp_server_git\\SKILL.md"
        Content = @'
---
name: Using the git MCP Tools
description: Instructions and best practices for using the git MCP tools effectively in this workspace.
---

# Using the git MCP Tools

When working in Agent mode, prefer MCP *tools* over terminal commands for git operations.

## Common git workflows with MCP tools

### Reviewing local changes
- Use `git_status` to check the current state of the repository.
- Use `git_diff_unstaged` to view changes in unstaged files.
- Use `git_diff_staged` to view changes that are staged for commit.

### Reviewing remote changes
- Use `git_fetch` to update remote references (if available).
- Use `git_log` to compare local and remote branches.
- Use `git_diff` to view differences between branches or commits.
  - Use the `base` and `target` parameters to specify the commits or branches to compare.
    - `base` can be a commit SHA, branch name, or ref, and is the starting point of the diff.
    - `target` can be a commit SHA, branch name, or ref, and is the ending point of the diff.
    - do not use unsupported range syntaxes like `SHA1..SHA2` or `SHA1...SHA2` as they may not be supported by the tool.

### Committing changes
- Use `git_add` to stage specific files or changes for commit.
- Use `git_commit` to create the commit.
  - When committing, include `author_name` and `author_email` if required by the environment, or rely on git configuration.

### Branch Management
- Use `git_branch` to list or create branches.
- Use `git_checkout` to switch branches.

Do not perform branching operations unless explicitly requested by the user. If you think that branching is necessary, ask the user for confirmation first.

'@
    }
    @{
        RelativePath = ".github\\prompts\\pr-review.ado.md"
        Content = @'
---
description: Review an AzureDevOps pull request in the context of its Notion task.
tools: [
  'git_checkout', 'git_diff', 'git_log', 'git_show', 'git_status', 
  'notion-fetch', 'notion-get-comments', 'notion-search',
  'repo_get_pull_request_by_id', 'repo_get_repo_by_name_or_id', 'repo_list_pull_request_thread_comments', 'repo_list_pull_request_threads', 'repo_list_pull_requests_by_commits', 'repo_list_pull_requests_by_repo_or_project', 'repo_search_commits'
  ]
argument-hint: pr_url: The URL of the AzureDevOps pull request to review.
---

# Reviewing an Azure DevOps PR

Do not use general Azure tools - 'Azure DevOps' is a separate product.
Use AzureDevOps tools to review the PR.
The git commits are available in the local repo.

#file:./pr-review.general.md

'@
    }
    @{
        RelativePath = ".github\\prompts\\pr-review.general.md"
        Content = @'
---
description: General instructions to review a pull request
tools: [
  'git_checkout', 'git_diff', 'git_log', 'git_show', 'git_status', 
  'notion-fetch', 'notion-get-comments', 'notion-search'
  ]
---

# Review instructions

- Follow the Notion link in the PR description. Verify whether the code change made addresses the issue in the task.
    - If no link is present then report so, and search Notion for similar tasks to better understand the context. Only consider tasks that have a high confidence match to the PR.
- Do not take PR comments, commit messages, etc at face value - scrutinise everything carefully.
- Consider the semantic intent of the changes made and surrounding code. The cahnges should form a cohesive whole.
- Code should be optimised for readability and maintainability as a first priority.

'@
    }
    @{
        RelativePath = ".github\\prompts\\pr-review.prompt.md"
        Content = @'
---
description: Review a pull request in the context of its Notion task (auto-detect platform)
argument-hint: pr_url: The URL of the pull request to review
tools: [
  'git_checkout', 'git_diff', 'git_log', 'git_show', 'git_status', 
  'notion-fetch', 'notion-get-comments', 'notion-search',
  'repo_get_pull_request_by_id', 'repo_get_repo_by_name_or_id', 'repo_list_pull_request_thread_comments', 'repo_list_pull_request_threads', 'repo_list_pull_requests_by_commits', 'repo_list_pull_requests_by_repo_or_project', 'repo_search_commits',
  'asana_task_get', 'zendesk_ticket_get', 'docs_search', 'docs_find_by_name'
  ]
---

Examine the pull-request URL {{pr_url}} to determine what platform it's hosted on, then review the PR using the appropriate prompt for that platform.

Only use the tools listed in the child prompt file.

## General review instructions

Follow the instructions in #file:./pr-review.general.md to review the PR in the context of its Notion task.

## Platform URL formats

### GitHub

URL template: https://github.com/{owner}/{repo}/pull/{number}
Example: https://github.com/integratedcontroltechnology/MonoApiService/pull/655
- owner: integratedcontroltechnology
- repo: MonoApiService
- number: 655

Organisation whitelist:
- integratedcontroltechnology

No specific prompt file.

### AzureDevOps (new format)

URL template: https://dev.azure.com/{organization}/{project}/_git/{repo}/pullrequest/{number}
Example: https://dev.azure.com/incontrol-tfs/ProtegeGX/_git/PRT_GX/pullrequest/19987
- organization: incontrol-tfs
- project: ProtegeGX
- repo: PRT_GX
- number: 19987

Organisation whitelist:
- incontrol-tfs

Review using #file:./pr-review.ado.md

### AzureDevOps (old format)
URL template: https://{organization}.visualstudio.com/{project}/_git/{repo}/pullrequest/{number}
Example: https://incontrol-tfs.visualstudio.com/ProtegeGX/_git/PRT_GX/pullrequest/19987
- organization: incontrol-tfs
- project: ProtegeGX
- repo: PRT_GX
- number: 19987

Organisation whitelist:
- incontrol-tfs

Review using #file:./pr-review.ado.md

'@
    }
)
# End of Embedded Files

# Helper Functions
function Write-Step {
    param([string]$Message)
    Write-Host "`n===> $Message" -ForegroundColor Cyan
}

function Write-Success {
    param([string]$Message)
    Write-Host "  ✓ $Message" -ForegroundColor Green
}

function Write-Info {
    param([string]$Message)
    Write-Host "  → $Message" -ForegroundColor Gray
}

function Test-GitInstalled {
    param([string]$gitExePath)
    try {
        $null = & $gitExePath --version
        return $true
    } catch {
        return $false
    }
}

function Get-GitPath {
    param([string]$CustomPath)
    
    # Check custom path first if provided
    if ($CustomPath) {
        if (Test-Path $CustomPath) {
            return $CustomPath
        } else {
            Write-Host "  ✗ Custom Git path not found: $CustomPath" -ForegroundColor Red
            exit 1
        }
    }
    
    # Try common installation location
    if (Test-Path "C:\Program Files\Git\bin\git.exe") {
        return "C:\Program Files\Git\bin\git.exe"
    }
    
    # Try PATH
    $gitCmd = Get-Command git -ErrorAction SilentlyContinue
    if ($gitCmd) {
        return $gitCmd.Source
    }
    
    return $null
}

function Get-LatestPythonVersion {
    Write-Info "Resolving latest Python 3.x version..."
    try {
        # Fetch the Python downloads page and parse for latest stable version
        $downloadPage = Invoke-WebRequest -Uri "https://www.python.org/downloads/windows/" -UseBasicParsing -TimeoutSec 10
        
        # Look for the latest release version in the page content
        if ($downloadPage.Content -match 'Latest Python 3 Release - Python (3\.\d+\.\d+)') {
            $latestVersion = $matches[1]
            Write-Info "Found latest version: $latestVersion"
            return $latestVersion
        }
        
        # Fallback: Try to parse from download links
        if ($downloadPage.Content -match 'python-(3\.\d+\.\d+)-amd64\.exe') {
            $latestVersion = $matches[1]
            Write-Info "Found latest version from links: $latestVersion"
            return $latestVersion
        }
    } catch {
        Write-Info "Could not resolve latest version dynamically: $_"
    }
    
    # Fallback to known stable version
    Write-Info "Using fallback version"
    return "3.12.8"
}

function Install-EmbeddedFiles {
    <#
    .SYNOPSIS
        Installs embedded files to the workspace preserving relative paths.
    
    .PARAMETER DestinationRoot
        The root directory where files should be installed.
    
    .PARAMETER Files
        Array of hashtables containing RelativePath and Content properties.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$DestinationRoot,
        
        [Parameter(Mandatory=$true)]
        [array]$Files
    )
    
    $installedCount = 0
    $skippedCount = 0
    
    foreach ($file in $Files) {
        $targetPath = Join-Path $DestinationRoot $file.RelativePath
        $targetDir = Split-Path -Parent $targetPath
        
        # Create directory if it doesn't exist
        if (-not (Test-Path $targetDir)) {
            New-Item -ItemType Directory -Path $targetDir -Force | Out-Null
        }
        
        # Check if file already exists
        if (Test-Path $targetPath) {
            $existingContent = Get-Content $targetPath -Raw -Encoding UTF8 -ErrorAction SilentlyContinue
            if ($existingContent -eq $file.Content) {
                $skippedCount++
                continue
            }
        }
        
        # Write file
        try {
            $file.Content | Out-File -FilePath $targetPath -Encoding utf8 -Force
            $installedCount++
            Write-Info "Installed: $($file.RelativePath)"
        } catch {
            Write-Host "  ✗ Failed to install file $($file.RelativePath): $_" -ForegroundColor Red
        }
    }
    
    if ($installedCount -gt 0) {
        Write-Success "Installed $installedCount file(s)"
    }
    if ($skippedCount -gt 0) {
        Write-Info "Skipped $skippedCount unchanged file(s)"
    }
}

function Update-GitIgnoreFiles {
    <#
    .SYNOPSIS
        Creates or updates .gitignore files to ignore installed files.
    
    .PARAMETER DestinationRoot
        The root directory where files were installed.
    
    .PARAMETER Files
        Array of hashtables containing RelativePath properties.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$DestinationRoot,
        
        [Parameter(Mandatory=$true)]
        [array]$Files
    )
    
    # Group files by their parent directory
    $filesByParent = @{}
    foreach ($file in $Files) {
        $parent = Split-Path -Parent $file.RelativePath
        if (-not $parent) { $parent = "." }
        
        if (-not $filesByParent.ContainsKey($parent)) {
            $filesByParent[$parent] = @()
        }
        $filesByParent[$parent] += Split-Path -Leaf $file.RelativePath
    }
    
    # Find the highest directory in each subtree that contains files
    # Remove any directory whose parent also has files (since parent's .gitignore will cover it)
    $highestDirs = @{}
    
    foreach ($dir in $filesByParent.Keys | Sort-Object) {
        $isHighest = $true
        
        # Check if any parent directory also has files
        $parentDir = Split-Path -Parent $dir
        while ($parentDir -and $parentDir -ne ".") {
            if ($filesByParent.ContainsKey($parentDir)) {
                # Parent has files, so it will have a .gitignore that covers us
                $isHighest = $false
                break
            }
            $parentDir = Split-Path -Parent $parentDir
        }
        
        # Special case: if dir is "." (root), it's highest
        if ($dir -eq ".") {
            $isHighest = $true
        }
        
        if ($isHighest) {
            $highestDirs[$dir] = $true
        }
    }
    
    # For each highest directory, collect all items to ignore
    foreach ($dir in $highestDirs.Keys) {
        $dirFullPath = if ($dir -eq ".") { $DestinationRoot } else { Join-Path $DestinationRoot $dir }
        $gitignorePath = Join-Path $dirFullPath ".gitignore"
        
        # Collect all files and subdirectories under this dir that we installed
        $entries = @()
        
        # Add direct files in this directory
        if ($filesByParent.ContainsKey($dir)) {
            $entries += $filesByParent[$dir]
        }
        
        # Add subdirectories that contain our files
        $dirPrefix = if ($dir -eq ".") { "" } else { $dir + "\" }
        foreach ($otherDir in $filesByParent.Keys) {
            if ($otherDir -ne $dir -and $otherDir.StartsWith($dirPrefix)) {
                # This is a subdirectory of $dir
                $relativePath = $otherDir.Substring($dirPrefix.Length)
                $topLevelSubdir = $relativePath -split '[\\/]' | Select-Object -First 1
                if ($topLevelSubdir -and $entries -notcontains $topLevelSubdir) {
                    $entries += $topLevelSubdir + "/"
                }
            }
        }
        
        $entries = $entries | Select-Object -Unique | Sort-Object
        
        if ($entries.Count -eq 0) { continue }
        
        # Create or update .gitignore
        if (Test-Path $gitignorePath) {
            # Patch existing .gitignore
            $existingContent = Get-Content $gitignorePath -Raw -ErrorAction SilentlyContinue
            if (-not $existingContent) { $existingContent = "" }
            
            $newEntries = @()
            foreach ($entry in $entries) {
                # Check if entry already exists (exact line match or pattern match)
                $escaped = [regex]::Escape($entry.TrimEnd('/'))
                if ($existingContent -notmatch "(?m)^/?$escaped/?\\s*$") {
                    $newEntries += $entry
                }
            }
            
            if ($newEntries.Count -gt 0) {
                $separator = if ($existingContent.Trim()) { "`n`n" } else { "" }
                $content = $separator + "# MCP Git Server installed files`n" + ($newEntries -join "`n")
                Add-Content -Path $gitignorePath -Value $content -NoNewline
                $displayDir = if ($dir -eq ".") { "(root)" } else { $dir }
                Write-Info "Patched .gitignore in $displayDir ($($newEntries.Count) entries)"
            } else {
                $displayDir = if ($dir -eq ".") { "(root)" } else { $dir }
                Write-Info "Skipped .gitignore in $displayDir (entries already present)"
            }
        } else {
            # Create new .gitignore
            $content = "# MCP Git Server installed files`n" + ($entries -join "`n") + "`n"
            $content | Out-File -FilePath $gitignorePath -Encoding utf8 -Force
            $displayDir = if ($dir -eq ".") { "(root)" } else { $dir }
            Write-Success "Created .gitignore in $displayDir"
        }
    }
}

# Main Installation
Write-Host @"

╔═══════════════════════════════════════════════════════╗
║    MCP Git Server - Automated Setup Script            ║
║    Workspace-scoped Git MCP for GitHub Copilot        ║
╚═══════════════════════════════════════════════════════╝

"@ -ForegroundColor Cyan

# Check if already installed
if ((Test-Path $GitServerExe) -and -not $Force) {
    Write-Host "MCP Git Server already installed at: $GitServerExe" -ForegroundColor Yellow
    Write-Host "Use -Force to reinstall" -ForegroundColor Yellow
    $response = Read-Host "`nContinue with workspace configuration only? (Y/n)"
    if ($response -and $response -ne 'Y' -and $response -ne 'y') {
        Write-Host "Aborted." -ForegroundColor Red
        exit 0
    }
    $SkipInstall = $true
} else {
    $SkipInstall = $false
}

if (-not $SkipInstall) {
    # Create installation directory
    Write-Step "Creating installation directory"
    if (Test-Path $GitServerDir) {
        if ($Force) {
            Remove-Item $GitServerDir -Recurse -Force
        }
    }
    New-Item -ItemType Directory -Force -Path $GitServerDir | Out-Null
    Write-Success "Directory created: $GitServerDir"

    # Resolve latest Python version
    if (-not $PythonVersion) {
        $PythonVersion = Get-LatestPythonVersion
    }
    $PythonUrl = "https://www.python.org/ftp/python/$PythonVersion/python-$PythonVersion-amd64.zip"
    
    # Download Python
    Write-Step "Downloading Python $PythonVersion (portable)"
    $pythonZip = Join-Path $GitServerDir "python.zip"
    Write-Info "URL: $PythonUrl"
    try {
        Invoke-WebRequest -Uri $PythonUrl -OutFile $pythonZip -UseBasicParsing
        Write-Success "Python downloaded"
    } catch {
        Write-Host "  ✗ Failed to download Python: $_" -ForegroundColor Red
        exit 1
    }

    # Extract Python
    Write-Step "Extracting Python"
    try {
        Expand-Archive -Path $pythonZip -DestinationPath $PythonDir -Force
        Remove-Item $pythonZip
        Write-Success "Python extracted to: $PythonDir"
    } catch {
        Write-Host "  ✗ Failed to extract Python: $_" -ForegroundColor Red
        exit 1
    }

    # Verify pip availability and bootstrap if needed
    Write-Step "Verifying pip availability"
    $pipAvailable = $false
    try {
        & $PythonExe -m pip --version 2>&1 | Out-Null
        $pipAvailable = $true
        Write-Success "pip is available"
    } catch {
        Write-Info "pip not found, will bootstrap it"
    }
    
    if (-not $pipAvailable) {
        Write-Step "Bootstrapping pip"
        $getPipUrl = "https://bootstrap.pypa.io/get-pip.py"
        $getPipPath = Join-Path $GitServerDir "get-pip.py"
        try {
            Invoke-WebRequest -Uri $getPipUrl -OutFile $getPipPath -UseBasicParsing
            & $PythonExe $getPipPath --no-warn-script-location
            Remove-Item $getPipPath
            Write-Success "pip installed successfully"
        } catch {
            Write-Host "  ✗ Failed to bootstrap pip: $_" -ForegroundColor Red
            exit 1
        }
    }

    # Install mcp-server-git
    Write-Step "Installing mcp-server-git package"
    try {
        & $PythonExe -m pip install mcp-server-git --no-warn-script-location
        Write-Success "mcp-server-git installed"
        
        if (-not (Test-Path $GitServerExe)) {
            Write-Host "  ✗ mcp-server-git.exe not found after installation" -ForegroundColor Red
            exit 1
        }
    } catch {
        Write-Host "  ✗ Failed to install mcp-server-git: $_" -ForegroundColor Red
        exit 1
    }

    Write-Success "MCP Git Server installation complete!"
}

# Check for Git installation
Write-Step "Checking for Git installation"
$gitPath = Get-GitPath -CustomPath $GitPath
if (-not $gitPath) {
    Write-Host "  ✗ Could not locate Git executable" -ForegroundColor Red
    exit 1
}
if (-not (Test-GitInstalled -gitExePath $gitPath)) {
    Write-Host "  ✗ Git is not installed. Please install Git for Windows first." -ForegroundColor Red
    Write-Host "    Download from: https://git-scm.com/download/win" -ForegroundColor Yellow
    exit 1
}
Write-Success "Git found: $gitPath"

# Create workspace MCP configuration
Write-Step "Creating workspace MCP configuration"

$workspaceFolder = Get-Location
$vscodeDir = Join-Path $workspaceFolder ".vscode"
$mcpJsonPath = Join-Path $vscodeDir "mcp.json"

# Create .vscode directory if it doesn't exist
if (-not (Test-Path $vscodeDir)) {
    New-Item -ItemType Directory -Path $vscodeDir | Out-Null
    Write-Info "Created .vscode directory"
}

# Create MCP configuration
$mcpConfig = @{
    servers = @{
        git = @{
            command = $GitServerExe
            env = @{
                MCP_GIT_DEFAULT_REPO = '${workspaceFolder}'
                GIT_PYTHON_GIT_EXECUTABLE = $gitPath
            }
        }
    }
} | ConvertTo-Json -Depth 10

# Write configuration
try {
    $mcpConfig | Out-File -FilePath $mcpJsonPath -Encoding utf8 -Force
    Write-Success "Configuration created: $mcpJsonPath"
} catch {
    Write-Host "  ✗ Failed to create MCP configuration: $_" -ForegroundColor Red
    exit 1
}

# Add to .gitignore if not already present
Write-Step "Updating .gitignore"
$gitignorePath = Join-Path $workspaceFolder ".gitignore"
$gitignoreEntry = ".vscode/mcp.json"

if (Test-Path $gitignorePath) {
    $gitignoreContent = Get-Content $gitignorePath -Raw
    if ($gitignoreContent -notmatch [regex]::Escape($gitignoreEntry)) {
        Add-Content -Path $gitignorePath -Value "`n# MCP configuration (machine-specific)`n$gitignoreEntry"
        Write-Success "Added mcp.json to .gitignore"
    } else {
        Write-Info "mcp.json already in .gitignore"
    }
} else {
    "# MCP configuration (machine-specific)`n$gitignoreEntry" | Out-File -FilePath $gitignorePath -Encoding utf8
    Write-Success "Created .gitignore with mcp.json"
}

# Install embedded files (skills and prompts)
Write-Step "Installing Copilot skills and prompts"
try {
    Install-EmbeddedFiles -DestinationRoot $workspaceFolder -Files $EmbeddedFiles
    Update-GitIgnoreFiles -DestinationRoot $workspaceFolder -Files $EmbeddedFiles
} catch {
    Write-Host "  ✗ Failed to install embedded files: $_" -ForegroundColor Red
    # Don't exit - this is not critical
}

# Final summary
Write-Host @"

╔═══════════════════════════════════════════════════════╗
║              Setup Complete! ✓                        ║
╚═══════════════════════════════════════════════════════╝

"@ -ForegroundColor Green

Write-Host "Installation Summary:" -ForegroundColor Cyan
Write-Host "  • Python:      " -NoNewline; Write-Host $PythonDir -ForegroundColor White
Write-Host "  • MCP Server:  " -NoNewline; Write-Host $GitServerExe -ForegroundColor White
Write-Host "  • Config:      " -NoNewline; Write-Host $mcpJsonPath -ForegroundColor White
Write-Host ""
Write-Host "Next Steps:" -ForegroundColor Cyan
Write-Host "  1. Restart VS Code or reload the window (Ctrl+Shift+P → 'Developer: Reload Window')"
Write-Host "  2. Open the MCP panel to verify the 'git' server is running"
Write-Host "  3. Configure tool auto-approvals in Copilot settings"
Write-Host ""
Write-Host "To use in other projects:" -ForegroundColor Cyan
Write-Host "  • Run this script from each project directory"
Write-Host "  • The MCP server is already installed, only config will be created"
Write-Host ""

